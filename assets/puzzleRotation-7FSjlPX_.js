import{J as l,m as n,n as s,p as c,A as p,s as i,B as u,q as d,H as z,I as y,x as w,y as g}from"./index-BmQksIZ3.js";const f=()=>{const e=new Date,r=5.5*60*60*1e3,t=new Date(e.getTime()+r),o=new Date(t);o.setUTCHours(0,0,0,0);const a=new Date(t);return a.setUTCHours(23,59,59,999),{start:o,end:a,now:t}},D=async()=>{var e;try{const r=n(s,"displayPuzzle","current"),t=await c(r);if(!t.exists())return console.log("No display puzzle found"),{expired:!0,puzzle:null};const o=t.data(),a=(e=o.expiryDate)==null?void 0:e.toDate();return!a||new Date>a?(console.log("Display puzzle has expired"),{expired:!0,puzzle:o}):{expired:!1,puzzle:o}}catch(r){return console.error("Error checking display puzzle expiry:",r),{expired:!0,puzzle:null}}},v=async e=>{try{if(!e)return;await p(i(s,"historyPuzzles"),{...e,movedToHistoryAt:u()}),console.log("Moved puzzle to history")}catch(r){throw console.error("Error moving puzzle to history:",r),r}},x=async()=>{try{const e=d(i(s,"approvedPuzzles"),z("createdAt","asc"),y(1)),r=await w(e);if(r.empty)return console.log("No approved puzzles available"),null;const t=r.docs[0];return{id:t.id,...t.data()}}catch(e){return console.error("Error getting next approved puzzle:",e),null}},m=async e=>{try{const{start:r,end:t}=f(),o=n(s,"displayPuzzle","current");return await g(o,{movieName:e.movieName,submittedBy:e.submittedBy,clues:e.clues,createdAt:e.createdAt,approvedAt:e.approvedAt,displayedAt:u(),expiryDate:t,sourceId:e.id}),await l(n(s,"approvedPuzzles",e.id)),console.log("Set new display puzzle with expiry:",t),!0}catch(r){throw console.error("Error setting display puzzle:",r),r}},A=async()=>{try{console.log("Checking if puzzle rotation is needed...");const{expired:e,puzzle:r}=await D();if(e){console.log("Puzzle expired or missing, rotating..."),r&&await v(r);const t=await x();return t?(await m(t),console.log("Successfully rotated to new puzzle"),{success:!0,newPuzzle:!0}):(console.log("No approved puzzles available for rotation"),r&&await l(n(s,"displayPuzzle","current")),{success:!1,reason:"no_approved_puzzles"})}else return console.log("Current puzzle is still valid"),{success:!0,newPuzzle:!1}}catch(e){return console.error("Error in puzzle rotation:",e),{success:!1,error:e}}},N=async()=>{try{const e=n(s,"displayPuzzle","current"),r=await c(e);return r.exists()?r.data():null}catch(e){return console.error("Error getting display puzzle:",e),null}};export{N as g,A as r};
